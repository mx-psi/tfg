
@book{LiIntroductionKolmogorovComplexity2008,
  address = {{New York, NY}},
  series = {Texts in {{Computer Science}}},
  title = {An {{Introduction}} to {{Kolmogorov Complexity}} and {{Its Applications}}},
  isbn = {978-0-387-33998-6 978-0-387-49820-1},
  urldate = {2017-10-10},
  publisher = {{Springer New York}},
  url = {http://link.springer.com/10.1007/978-0-387-49820-1},
  author = {Li, Ming and Vit{\'a}nyi, Paul},
  year = {2008},
  file = {/home/pablo/Zotero/storage/ZBRWG9UA/[Ming_Li,_Paul_M.B._Vit√°nyi]_An_Introduction_to_K(BookFi).pdf},
  doi = {10.1007/978-0-387-49820-1},
  annote = {Pinta muy guay aunque no creo que tenga cabida en el TFG}
}

@book{MitzenmacherProbabilitycomputingintroduction2005,
  address = {{New York}},
  title = {Probability and Computing: An Introduction to Randomized Algorithms and Probabilistic Analysis},
  isbn = {978-0-521-83540-4},
  lccn = {QA274 .M574 2005},
  shorttitle = {Probability and Computing},
  publisher = {{Cambridge University Press}},
  author = {Mitzenmacher, Michael and Upfal, Eli},
  year = {2005},
  keywords = {Probabilities,Algorithms,Stochastic analysis},
  file = {/home/pablo/Zotero/storage/583ENAHG/Randomized Algorithms.pdf},
  annote = {Includes index}
}

@unpublished{WigdersonComputationalcomplexitytheory2017,
  title = {Computational Complexity Theory},
  url = {https://www.math.ias.edu/avi/book},
  author = {Wigderson, Avi},
  year = {2017},
  file = {/home/pablo/Zotero/storage/STAESHCF/mathandcomp.pdf},
  annote = {Tiene bastantes cosas de interactive proofs (incluido en cu{\'a}ntica)}
}

@book{SavageModelsComputation,
  title = {Models of {{Computation}}},
  author = {Savage, John},
  file = {/home/pablo/Zotero/storage/T75KIIP4/ModelsOfComputation.pdf},
  annote = {Trata circuitos cl{\'a}sicos bien}
}

@book{SipserIntroductionTheoryComputation,
  title = {Introduction to the {{Theory}} of {{Computation}}},
  author = {Sipser, Michael},
  file = {/home/pablo/Zotero/storage/ZRZMUZM6/IntroductionToTheTheoryOfComputation.djvu}
}

@book{HighamHandbookWritingMathematical,
  title = {Handbook of {{Writing}} for the {{Mathematical Sciences}}},
  author = {Higham, Nicholas},
  file = {/home/pablo/Zotero/storage/R9UBRXF6/Higham - Handbook of Writing for the Mathematical Sciences.djvu}
}

@article{GreenlawCompendiumProblemsComplete1991,
  title = {A {{Compendium}} of {{Problems Complete}} for {{P}} ({{Preliminary}})},
  author = {Greenlaw, Raymond and Hoover, James and Ruzzo, Walter L.},
  year = {1991},
  file = {/home/pablo/Zotero/storage/EXPW33CZ/Greenlaw et al. - 1991 - A Compendium of Problems Complete for P (Prelimina.pdf}
}

@book{YanofskyQuantumcomputingcomputer2008,
  address = {{Cambridge}},
  title = {Quantum Computing for Computer Scientists},
  isbn = {978-0-521-87996-5},
  lccn = {QA76.889 .Y35 2008},
  publisher = {{New York : Cambridge University Press}},
  author = {Yanofsky, Noson S. and Mannucci, Mirco A.},
  year = {2008},
  keywords = {Quantum computers},
  file = {/home/pablo/Zotero/storage/GZJEJKWC/Noson S. Yanofsky, Mirco A. Mannucci-Quantum Computing for Computer Scientists-Cambridge University Press (2008).pdf},
  note = {OCLC: ocn212859032}
}

@book{Kayeintroductionquantumcomputing2007,
  address = {{Oxford}},
  title = {An Introduction to Quantum Computing},
  isbn = {978-0-19-857000-4 978-0-19-857049-3},
  language = {eng},
  publisher = {{Oxford Univ. Press}},
  author = {Kaye, Phillip and Laflamme, Raymond and Mosca, Michele},
  year = {2007},
  file = {/home/pablo/Zotero/storage/3JN74D4G/Phillip Kaye, Raymond Laflamme, Michele Mosca-An introduction to quantum computing-Oxford University Press, USA (2007).pdf},
  note = {OCLC: 255412511},
  annote = {Literaturverz. S. 260 - 269 Hier auch sp{\"a}ter erschienene, unver{\"a}nderte Nachdrucke

Muy muy detallado 10/10}
}

@book{SteebProblemssolutionsquantum2004,
  address = {{River Edge, N.J}},
  title = {Problems \& Solutions in Quantum Computing \& Quantum Information},
  isbn = {978-981-238-789-9 978-981-238-790-5},
  lccn = {QA76.889 .S74 2004},
  publisher = {{World Scientific}},
  author = {Steeb, W.-H. and Hardy, Yorick},
  year = {2004},
  keywords = {Quantum computers,Quantum theory},
  file = {/home/pablo/Zotero/storage/36AGQY39/Problems & Solutions in Quantum Computing & Quantum Information.pdf},
  note = {OCLC: ocm55198361}
}

@article{BookatzQMAcompleteproblems2012,
  title = {{{QMA}}-Complete Problems},
  journal = {arXiv preprint arXiv:1212.6312},
  author = {Bookatz, Adam D.},
  year = {2012},
  file = {/home/pablo/Zotero/storage/IXFMEQBJ/Bookatz - 2012 - QMA-complete problems.pdf}
}

@article{GayQuantumprogramminglanguages2006,
  title = {Quantum Programming Languages: {{Survey}} and Bibliography},
  volume = {16},
  shorttitle = {Quantum Programming Languages},
  number = {4},
  journal = {Mathematical Structures in Computer Science},
  author = {Gay, Simon J.},
  year = {2006},
  keywords = {Quantum Programming Languages},
  pages = {581--600},
  file = {/home/pablo/Zotero/storage/SVVJTK6J/Gay - 2006 - Quantum programming languages Survey and bibliogr.pdf},
  annote = {Interesante para sacar referencias para leer pero el texto tampoco dice nada relevante}
}

@article{FortnowOnecomplexitytheorist2003,
  title = {One Complexity Theorist's View of Quantum Computing},
  volume = {292},
  number = {3},
  journal = {Theoretical Computer Science},
  author = {Fortnow, Lance},
  year = {2003},
  pages = {597--610},
  file = {/home/pablo/Zotero/storage/N3224Z88/Fortnow - 2003 - One complexity theorist's view of quantum computin.pdf}
}

@article{WatrousQuantumComputationalComplexity2009,
  title = {Quantum {{Computational Complexity}}},
  language = {en},
  urldate = {2018-03-13},
  journal = {Encyclopedia of Complexity and Systems Science},
  url = {http://link.springer.com/10.1007/978-0-387-30440-3_428},
  author = {Watrous, John},
  collaborator = {Meyers, Robert A.},
  year = {2009},
  pages = {7174-7201},
  file = {/home/pablo/Zotero/storage/V4B6V9RU/Watrous - 2009 - Quantum Computational Complexity.pdf},
  doi = {10.1007/978-0-387-30440-3_428}
}

@article{DiPierroReversiblecombinatorylogic2006,
  title = {Reversible Combinatory Logic},
  volume = {16},
  issn = {0960-1295, 1469-8072},
  language = {en},
  number = {04},
  urldate = {2018-03-13},
  journal = {Mathematical Structures in Computer Science},
  doi = {10.1017/S0960129506005391},
  url = {http://www.journals.cambridge.org/abstract_S0960129506005391},
  author = {Di Pierro, Alessandra and Hankin, Chris and Wiklicky, Herbert},
  month = aug,
  year = {2006},
  pages = {621},
  file = {/home/pablo/Zotero/storage/TCR9Q637/Di Pierro et al. - 2006 - Reversible combinatory logic.pdf}
}

@article{VadhanPseudorandomness2012,
  title = {Pseudorandomness},
  volume = {7},
  issn = {1551-305X, 1551-3068},
  abstract = {This is a survey of pseudorandomness, the theory of efficiently generating objects that ``look random'' despite being constructed using little or no randomness. This theory has significance for a number of areas in computer science and mathematics, including computational complexity, algorithms, cryptography, combinatorics, communications, and additive number theory. Our treatment places particular emphasis on the intimate connections that have been discovered between a variety of fundamental ``pseudorandom objects'' that at first seem very different in nature: expander graphs, randomness extractors, list-decodable error-correcting codes, samplers, and pseudorandom generators. The structure of the presentation is meant to be suitable for teaching in a graduate-level course, with exercises accompanying each section.},
  language = {en},
  number = {1-3},
  urldate = {2018-03-15},
  journal = {Foundations and Trends\textregistered{} in Theoretical Computer Science},
  doi = {10.1561/0400000010},
  url = {http://www.nowpublishers.com/article/Details/TCS-010},
  author = {Vadhan, Salil P.},
  year = {2012},
  pages = {1-336},
  file = {/home/pablo/Zotero/storage/HTDV57R7/Vadhan - 2012 - Pseudorandomness.pdf}
}

@article{BLUMMachineIndependentTheoryComplexity,
  title = {A {{Machine}}-{{Independent Theory}} of the {{Complexity}} of {{Recursive Functions}}},
  abstract = {The number of steps required to compute a function depends, in general, on the type of computer that is used, on the choice of computer program, and on the input-output code. Nevertheless, the results obtained in this paper are so general as to be nearly independent of these considerations. A function is exhibited that requires an enormous number of steps to be computed, yet has a "nearly quickest" program: Any other program for this function, no matter how ingeniously designed it may be, takes practically as many steps as this nearly quickest program.},
  language = {en},
  author = {BLUM, MANUEL},
  pages = {15},
  file = {/home/pablo/Zotero/storage/7FS5QT9F/BLUM - A Machine-Independent 'i'] ~eo5iy' of the Complex.pdf},
  annote = {Est{\'a} bien como referencia al speedup theorem que puede estar bien mencionar como introducci{\'o}n a la complejidad cl{\'a}sica.}
}

@inproceedings{AaronsonBQPpolynomialhierarchy2010,
  title = {{{BQP}} and the Polynomial Hierarchy},
  isbn = {978-1-4503-0050-6},
  abstract = {The relationship between BQP and PH has been an open problem since the earliest days of quantum computing. We present evidence that quantum computers can solve problems outside the entire polynomial hierarchy, by relating this question to topics in circuit complexity, pseudorandomness, and Fourier analysis.},
  language = {en},
  urldate = {2018-05-02},
  publisher = {{ACM Press}},
  doi = {10.1145/1806689.1806711},
  url = {http://dl.acm.org/citation.cfm?doid=1806689.1806711},
  author = {Aaronson, Scott},
  year = {2010},
  pages = {141},
  file = {/home/pablo/Zotero/storage/TMYMJ6D3/Aaronson - 2010 - BQP and the polynomial hierarchy.pdf},
  annote = {Es un resultado que se puede mencionar pero que no parece muy interesante por ser muy d{\'e}bil y requerir mucho desarrollo para poder explicarlo bien.}
}

@incollection{GoldreichNotesLevinTheory2011,
  address = {{Berlin, Heidelberg}},
  title = {Notes on {{Levin}}'s {{Theory}} of {{Average}}-{{Case Complexity}}},
  volume = {6650},
  isbn = {978-3-642-22669-4 978-3-642-22670-0},
  abstract = {In 1984, Leonid Levin initiated a theory of average-case complexity. We provide an exposition of the basic definitions suggested by Levin, and discuss some of the considerations underlying these definitions.},
  language = {en},
  urldate = {2018-05-31},
  booktitle = {Studies in {{Complexity}} and {{Cryptography}}. {{Miscellanea}} on the {{Interplay}} between {{Randomness}} and {{Computation}}},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/978-3-642-22670-0_21},
  author = {Goldreich, Oded},
  editor = {Goldreich, Oded},
  year = {2011},
  pages = {233-247},
  file = {/home/pablo/Zotero/storage/CDRFP8JZ/Goldreich - 2011 - Notes on Levin‚Äôs Theory of Average-Case Complexity.pdf},
  doi = {10.1007/978-3-642-22670-0_21},
  annote = {el cierre por composici{\'o}n y la independencia de la m{\'a}quina donde se exprese son dos condiciones importantes a la hora de la robustez/naturalidad de una clase}
}

@book{TakhtajanQuantumMechanicsMathematicians2008,
  address = {{Providence, Rhode Island}},
  series = {Graduate {{Studies}} in {{Mathematics}}},
  title = {Quantum {{Mechanics}} for {{Mathematicians}}},
  volume = {95},
  isbn = {978-0-8218-4630-8 978-1-4704-1162-6},
  language = {en},
  urldate = {2018-06-04},
  publisher = {{American Mathematical Society}},
  url = {http://www.ams.org/gsm/095},
  author = {Takhtajan, Leon},
  month = aug,
  year = {2008},
  file = {/home/pablo/Zotero/storage/25LQJD9C/Takhtajan - 2008 - Quantum Mechanics for Mathematicians.pdf},
  doi = {10.1090/gsm/095}
}

@book{FaddeevLecturesquantummechanics2009,
  address = {{Providence, R.I}},
  edition = {English ed.},
  series = {Student Mathematical Library},
  title = {Lectures on Quantum Mechanics for Mathematics Students},
  isbn = {978-0-8218-4699-5},
  lccn = {QC174.125 .F3213 2009},
  language = {en},
  number = {v. 47},
  publisher = {{American Mathematical Society}},
  author = {Faddeev, L. D.},
  year = {2009},
  keywords = {Quantum theory},
  file = {/home/pablo/Zotero/storage/RSIAIBRU/Faddeev y IÔ∏†AÔ∏°kubovskiƒ≠ - 2009 - Lectures on quantum mechanics for mathematics stud.pdf},
  note = {OCLC: ocn278980827}
}

@book{NielsenQuantumComputationQuantum2010,
  edition = {10th Anniversary Edition},
  title = {Quantum {{Computation}} and {{Quantum Information}}},
  isbn = {978-1-107-61919-7},
  publisher = {{Cambridge University Press}},
  author = {Nielsen, Michael A. and Chuang, Isaac L.},
  year = {2010},
  file = {/home/pablo/Zotero/storage/IHARMVVI/18.436-Michael A. Nielsen, Isaac L. Chuang Quantum computation and quantum information  2004.pdf},
  annote = {Me he saltado la secci{\'o}n 4.3}
}

@incollection{AaronsonmathoplimitsNP2016,
  title = {$\mathsf{P} \overset{?}{=} \mathsf{NP}$},
  isbn = {978-3-319-32160-8 978-3-319-32162-2},
  abstract = {In 1950, John Nash sent a remarkable letter to the National Security Agency, in which\textemdash{}seeking to build theoretical foundations for cryptography\textemdash{}he all but formulated what today we call the P=?NPP=?‚Å°NP\textbackslash{}mathsf\{P\}\textbackslash{}mathop\{ =\}\textbackslash{}limits\^\{?\}\textbackslash{}mathsf\{NP\} problem, and consider one of the great open problems of science. Here I survey the status of this problem in 2016, for a broad audience of mathematicians, scientists, and engineers. I offer a personal perspective on what it's about, why it's important, why it's reasonable to conjecture that P {$\not =$} NP is both true and provable, why proving it is so hard, the landscape of related problems, and crucially, what progress has been made in the last half-century toward solving those problems. The discussion of progress includes diagonalization and circuit lower bounds; the relativization, algebrization, and natural proofs barriers; and the recent works of Ryan Williams and Ketan Mulmuley, which (in different ways) hint at a duality between impossibility proofs and algorithms.},
  language = {en},
  urldate = {2018-07-05},
  booktitle = {Open {{Problems}} in {{Mathematics}}},
  publisher = {{Springer, Cham}},
  url = {https://link.springer.com/chapter/10.1007/978-3-319-32162-2_1},
  author = {Aaronson, Scott},
  year = {2016},
  pages = {1-122},
  file = {/home/pablo/Zotero/storage/GSV9VQ66/pnp.pdf;/home/pablo/Zotero/storage/99EMS8FT/978-3-319-32162-2_1.html},
  doi = {10.1007/978-3-319-32162-2_1}
}

@book{ImmermanDescriptiveComplexity2012,
  title = {Descriptive {{Complexity}}},
  isbn = {978-1-4612-0539-5},
  abstract = {A basic issue in computer science is the complexity of problems. Computational complexity measures how much time or memory is needed as a function of the input problem size. Descriptive complexity is concerned with problems which may be described in first-order logic. By virtue of the close relationship between logic and relational databses, it turns out that this subject has important applications to databases such as analysing the queries computable in polynomial time, analysing the parallel time needed to compute a query, and the analysis of nondeterministic classes. This book is written as a graduate text and so aims to provide a reasonably self-contained introduction to this subject. The author has provided numerous examples and exercises to further illustrate the ideas presented.},
  language = {en},
  publisher = {{Springer Science \& Business Media}},
  author = {Immerman, Neil},
  month = dec,
  year = {2012},
  keywords = {Computers / Computer Science,Computers / Information Technology,Computers / Networking / General,Computers / Online Services,Mathematics / History \& Philosophy,Mathematics / Logic},
  file = {/home/pablo/Zotero/storage/EDTH84NM/Descriptive-Complexity.djvu}
}

@article{HopcroftIntroductionAutomataTheory2001,
  title = {Introduction to {{Automata Theory}}, {{Languages}}, and {{Computation}}, {{2Nd Edition}}},
  volume = {32},
  issn = {0163-5700},
  number = {1},
  urldate = {2018-07-05},
  journal = {SIGACT News},
  doi = {10.1145/568438.568455},
  url = {http://doi.acm.org/10.1145/568438.568455},
  author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
  month = mar,
  year = {2001},
  pages = {60--65},
  file = {/home/pablo/Zotero/storage/G8JWTYXC/Introduction To Automata Theory.pdf}
}

@incollection{PapadimitriouComputationalComplexity,
  address = {{Chichester, UK}},
  title = {Computational {{Complexity}}},
  isbn = {978-0-470-86412-8},
  abstract = {Once we have developed an algorithm (q.v.) for solving a computational problem and analyzed its worst-case time requirements as a function of the size of its input (most usefully, in terms of the O-notation; see ALGORITHMS, ANALYSIS OF), it is inevitable to ask the question: "Can we do better?" In a typical problem, we may be able to devise new algorithms for the problem that are more and more efficient. But eventually, this line of research often seems to hit an invisible barrier, a level beyond whch improvements are very difficult, seemingly impossible, to come by. After many unsuccessful attempts, algorithm designers inevitably start to wonder if there is something inherent in the problem that makes it impossible to devise algorithms that are faster than the current one. They may try to develop mathematical techniques for proving formally that there can be no algorithm for the given problem which runs faster than the current one. Such a proof would be valuable, as it would suggest that it is futile to keep working on improved algorithms for this problem, that further improvements are certainly impossible. The realm of mathematical models and techniques for establishing such impossibility proofs is called computational complexity.},
  urldate = {2018-07-05},
  booktitle = {Encyclopedia of {{Computer Science}}},
  publisher = {{John Wiley and Sons Ltd.}},
  url = {http://dl.acm.org/citation.cfm?id=1074100.1074233},
  author = {Papadimitriou, Christos H.},
  pages = {260--265},
  file = {/home/pablo/Zotero/storage/36BMS6NR/[Papadimitriou]_Computational_Complexity.djvu}
}

@article{JozsaQuantumFactoringDiscrete2001,
  title = {Quantum {{Factoring}}, {{Discrete Logarithms}}, and the {{Hidden Subgroup Problem}}},
  volume = {3},
  issn = {1521-9615},
  number = {2},
  urldate = {2018-07-05},
  journal = {Computing in Science \& Engineering},
  doi = {10.1109/5992.909000},
  url = {https://aip.scitation.org/doi/abs/10.1109/5992.909000},
  author = {Jozsa, Richard},
  month = mar,
  year = {2001},
  pages = {34-43},
  file = {/home/pablo/Zotero/storage/ZUXC75A6/Quantum factoring, discrete logarithms and the hidden subgroup problem.pdf;/home/pablo/Zotero/storage/P8TNL9GR/5992.html}
}

@book{AaronsonQuantumComputingDemocritus2013,
  title = {Quantum {{Computing Since Democritus}}},
  isbn = {978-0-521-19956-8},
  abstract = {Written by noted quantum computing theorist Scott Aaronson, this book takes readers on a tour through some of the deepest ideas of maths, computer science and physics. Full of insights, arguments and philosophical perspectives, the book covers an amazing array of topics. Beginning in antiquity with Democritus, it progresses through logic and set theory, computability and complexity theory, quantum computing, cryptography, the information content of quantum states and the interpretation of quantum mechanics. There are also extended discussions about time travel, Newcomb's Paradox, the anthropic principle and the views of Roger Penrose. Aaronson's informal style makes this fascinating book accessible to readers with scientific backgrounds, as well as students and researchers working in physics, computer science, mathematics and philosophy.},
  language = {en},
  publisher = {{Cambridge University Press}},
  author = {Aaronson, Scott},
  month = mar,
  year = {2013},
  keywords = {Science / Physics / General,Science / Physics / Quantum Theory},
  file = {/home/pablo/Zotero/storage/L25ZQXDJ/[Scott_Aaronson]_Quantum_Computing_since_Democritu(BookZZ.org).epub}
}

@book{VaziraniApproximationAlgorithms2013,
  title = {Approximation {{Algorithms}}},
  isbn = {978-3-662-04565-7},
  abstract = {Although this may seem a paradox, all exact science is dominated by the idea of approximation. Bertrand Russell (1872-1970) Most natural optimization problems, including those arising in important application areas, are NP-hard. Therefore, under the widely believed con jecture that P -=/= NP, their exact solution is prohibitively time consuming. Charting the landscape of approximability of these problems, via polynomial time algorithms, therefore becomes a compelling subject of scientific inquiry in computer science and mathematics. This book presents the theory of ap proximation algorithms as it stands today. It is reasonable to expect the picture to change with time. This book is divided into three parts. In Part I we cover combinato rial algorithms for a number of important problems, using a wide variety of algorithm design techniques. The latter may give Part I a non-cohesive appearance. However, this is to be expected - nature is very rich, and we cannot expect a few tricks to help solve the diverse collection of NP-hard problems. Indeed, in this part, we have purposely refrained from tightly cat egorizing algorithmic techniques so as not to trivialize matters. Instead, we have attempted to capture, as accurately as possible, the individual character of each problem, and point out connections between problems and algorithms for solving them.},
  language = {en},
  publisher = {{Springer Science \& Business Media}},
  author = {Vazirani, Vijay V.},
  month = mar,
  year = {2013},
  keywords = {Computers / Computer Science,Computers / Information Technology,Business \& Economics / Operations Research,Computers / Data Processing,Computers / Programming / Algorithms,Mathematics / Combinatorics,Mathematics / Discrete Mathematics},
  file = {/home/pablo/Zotero/storage/4WCY2RNK/Vijay V. Vazirani - Approximation algorithms (2004, Springer).pdf}
}

@book{LiptonQuantumalgorithmslinear2014,
  address = {{Cambridge, Massachusetts}},
  title = {Quantum Algorithms via Linear Algebra: A Primer},
  isbn = {978-0-262-02839-4},
  lccn = {QA76.889 .L57 2014},
  shorttitle = {Quantum Algorithms via Linear Algebra},
  language = {en},
  publisher = {{The MIT Press}},
  author = {Lipton, Richard J. and Regan, Kenneth W.},
  year = {2014},
  keywords = {Computer algorithms,Quantum computers,Algebras; Linear,BQP},
  file = {/home/pablo/Zotero/storage/RYLLDQGU/Lipton y Regan - 2014 - Quantum algorithms via linear algebra a primer.pdf}
}

@book{RieffelQuantumcomputinggentle2011,
  address = {{Cambridge, Mass}},
  series = {Scientific and Engineering Computation},
  title = {Quantum Computing: A Gentle Introduction},
  isbn = {978-0-262-01506-6},
  lccn = {QA76.889 .R54 2011},
  shorttitle = {Quantum Computing},
  language = {en},
  publisher = {{The MIT Press}},
  author = {Rieffel, Eleanor and Polak, Wolfgang},
  year = {2011},
  keywords = {Quantum computers,Quantum theory},
  file = {/home/pablo/Zotero/storage/6N44FTXN/Rieffel y Polak - 2011 - Quantum computing a gentle introduction.pdf},
  note = {OCLC: ocn641998800}
}

@book{VollmerIntroductioncircuitcomplexity1999,
  address = {{Berlin ; New York}},
  series = {Texts in Theoretical Computer Science},
  title = {Introduction to Circuit Complexity: A Uniform Approach},
  isbn = {978-3-540-64310-4},
  lccn = {TK7888.4 .V65 1999},
  shorttitle = {Introduction to Circuit Complexity},
  language = {en},
  publisher = {{Springer}},
  author = {Vollmer, Heribert},
  year = {1999},
  keywords = {Algebra; Boolean,Circuits Design,Computational complexity,Electronic digital computers,Logic; Symbolic and mathematical},
  file = {/home/pablo/Zotero/storage/XNRDTFQ6/Vollmer - 1999 - Introduction to circuit complexity a uniform appr.pdf},
  annote = {Es el que tiene la definici{\'o}n m{\'a}s expl{\'i}cita de circuito que he visto. Por lo dem{\'a}s bastante t{\'e}cnico.}
}

@misc{oraclemachinesComplexity,
  title = {Oracle Machines - {{Complexity}} Classes Where \${{C}}\^{{C}} = {{C}}\$},
  urldate = {2018-07-11},
  journal = {Computer Science Stack Exchange},
  url = {https://cs.stackexchange.com/questions/13876/complexity-classes-where-cc-c},
  file = {/home/pablo/Zotero/storage/SKMWN4AK/complexity-classes-where-cc-c.html}
}

@article{AaronsonQuantumMachineLearning,
  title = {Quantum {{Machine Learning Algorithms}}: {{Read}} the {{Fine Print}}},
  language = {en},
  author = {Aaronson, Scott},
  keywords = {todo},
  pages = {5},
  file = {/home/pablo/Zotero/storage/36E9R32U/Aaronson - Quantum Machine Learning Algorithms Read the Fine.pdf}
}

@book{BalcazarStructuralComplexityII1990,
  address = {{Berlin, Heidelberg}},
  title = {Structural {{Complexity II}}},
  isbn = {978-3-642-75359-6 978-3-642-75357-2},
  language = {en},
  urldate = {2018-07-18},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/978-3-642-75357-2},
  author = {Balc{\'a}zar, Jos{\'e} Luis and D{\'i}az, Josep and Gabarr{\'o}, Joaquim},
  year = {1990},
  file = {/home/pablo/Zotero/storage/NIH57UG8/Balc√°zar et al. - 1990 - Structural Complexity II.pdf},
  doi = {10.1007/978-3-642-75357-2},
  annote = {El cap{\'i}tulo "Positive Relativizations" tiene algo sobre por qu{\'e} los resultados relativizados pueden ser {\'u}tiles}
}

@book{BalcazarStructuralComplexity1988,
  address = {{Berlin, Heidelberg}},
  title = {Structural {{Complexity I}}},
  isbn = {978-3-642-97062-7 978-3-540-18622-9},
  abstract = {This is the first of two volumes which present, in a systematic manner, the various areas of research in the field of structural complexity. Since the achievement of a formal definition of the concept of "algorithm", the Mathematical Theory of Computation has developed into a broad and rich discipline. The notion of "complexity of an algorithm" yields an important area of research, known as Complexity Theory, that can be approached from several points of view. The present Volume I is written in a style appropriate for undergraduate students who have taken a first course in Formal Language Theory. The first two chapters of this volume present the basic concepts of structural complexity, providing the background necessary for the understanding of complexity theory. Volume II will be addressed to graduate students and researchers. Both volumes are written in a textbook style; they contain about 200 exercises. The readers are led to a point where very little additional work will enable them to start research projects. In order to ease this step, an effort has been made to point out the main references for each of the results presented in the text.},
  language = {en},
  urldate = {2018-07-18},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://public.eblib.com/choice/publicfullrecord.aspx?p=3097731},
  author = {Balc{\'a}zar, Jos{\'e} Luis and D{\'i}az, Josep and Gabarr{\'o}, Joaquim},
  year = {1988},
  file = {/home/pablo/Zotero/storage/5NCRDKEL/Balc√°zar et al. - 1988 - Structural Complexity I.pdf},
  note = {OCLC: 851384755}
}

@article{BernsteinQuantumComplexityTheory,
  title = {Quantum {{Complexity Theory}}},
  abstract = {In this paper we study quantum computation from a complexity theoretic viewpoint. Our first result is the existence of an efficient universal quantum Turing machine in Deutsch's model of a quantum Turing machine (QTM) [Proc. Roy. Soc. London Ser. A, 400 (1985), pp. 97\textendash{}117]. This construction is substantially more complicated than the corresponding construction for classical Turing machines (TMs); in fact, even simple primitives such as looping, branching, and composition are not straightforward in the context of quantum Turing machines. We establish how these familiar primitives can be implemented and introduce some new, purely quantum mechanical primitives, such as changing the computational basis and carrying out an arbitrary unitary transformation of polynomially bounded dimension.},
  language = {en},
  author = {Bernstein, Ethan and Vazirani, Umesh},
  pages = {63},
  file = {/home/pablo/Zotero/storage/NQCQX2GJ/Bernstein y Vazirani - Quantum Complexity Theory.pdf}
}

@misc{Whatgoodoracle,
  title = {What Good Is Oracle Separation? {{The}} Recent Separation between {{BQP}} and {{PH}}, for Ex... | {{Hacker News}}},
  urldate = {2018-07-23},
  url = {https://news.ycombinator.com/item?id=17425924},
  file = {/home/pablo/Zotero/storage/7GJQQI6B/item.html},
  annote = {Summary of points made:

- Oracle separations are similar to query complexity

- Proving oracle results can give insight into new proof techniques or how they fail.

- Aaronson has some reason to believe (by analogy with other areas of mathematics?) that proving this results would be necessary for proving the unrelativized ones

- There are some actual examples of relations between relativized results and some other result with no oracle (relativized PH vs PSPACE is related to AC0 being unable to calculate PARITY).

~}
}

@article{FortnowRoleRelativizationComplexity,
  title = {The {{Role}} of {{Relativization}} in {{Complexity Theory}}},
  abstract = {Several recent nonrelativizing results in the area of interactive proofs have caused many people to review the importance of relativization. In this paper we take a look at how complexity theorists use and misuse oracle results. We pay special attention to the new interactive proof systems and program checking results and try to understand why they do not relativize. We give some new results that may help us to understand these questions better.},
  language = {en},
  author = {Fortnow, Lance},
  pages = {15},
  file = {/home/pablo/Zotero/storage/UHWZW55P/Fortnow - The Role of Relativization in Complexity Theory.pdf},
  annote = {Some points on the usefulness of oracle results}
}

@article{AmbainisUnderstandingQuantumAlgorithms2017,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1712.06349},
  primaryClass = {quant-ph},
  title = {Understanding {{Quantum Algorithms}} via {{Query Complexity}}},
  abstract = {Query complexity is a model of computation in which we have to compute a function \$f(x\_1, \textbackslash{}ldots, x\_N)\$ of variables \$x\_i\$ which can be accessed via queries. The complexity of an algorithm is measured by the number of queries that it makes. Query complexity is widely used for studying quantum algorithms, for two reasons. First, it includes many of the known quantum algorithms (including Grover's quantum search and a key subroutine of Shor's factoring algorithm). Second, one can prove lower bounds on the query complexity, bounding the possible quantum advantage. In the last few years, there have been major advances on several longstanding problems in the query complexity. In this talk, we survey these results and related work, including: - the biggest quantum-vs-classical gap for partial functions (a problem solvable with 1 query quantumly but requiring \$\textbackslash{}Omega(\textbackslash{}sqrt\{N\})\$ queries classically); - the biggest quantum-vs-determistic and quantum-vs-probabilistic gaps for total functions (for example, a problem solvable with \$M\$ queries quantumly but requiring \$\textbackslash{}tilde\{\textbackslash{}Omega\}(M\^\{2.5\})\$ queries probabilistically); - the biggest probabilistic-vs-deterministic gap for total functions (a problem solvable with \$M\$ queries probabilistically but requiring \$\textbackslash{}tilde\{\textbackslash{}Omega\}(M\^\{2\})\$ queries deterministically); - the bounds on the gap that can be achieved for subclasses of functions (for example, symmetric functions); - the connections between query algorithms and approximations by low-degree polynomials.},
  language = {en},
  urldate = {2018-07-23},
  journal = {arXiv:1712.06349 [quant-ph]},
  url = {http://arxiv.org/abs/1712.06349},
  author = {Ambainis, Andris},
  month = dec,
  year = {2017},
  keywords = {Quantum Physics,Computer Science - Computational Complexity},
  file = {/home/pablo/Zotero/storage/MTD9IPSK/Ambainis - 2017 - Understanding Quantum Algorithms via Query Complex.pdf},
  annote = {Comment: 20 page survey of recent results, for Proceedings of International Congress of Mathematicians'2018}
}

@misc{complexitytheoryWhy,
  title = {Complexity Theory - {{Why}} Is a Quantum Computer in Some Ways More Powerful than a Nondeterministic {{Turing}} Machine?},
  urldate = {2018-07-28},
  journal = {Quantum Computing Stack Exchange},
  url = {https://quantumcomputing.stackexchange.com/questions/1359/why-is-a-quantum-computer-in-some-ways-more-powerful-than-a-nondeterministic-tur},
  file = {/home/pablo/Zotero/storage/THBWU6SP/why-is-a-quantum-computer-in-some-ways-more-powerful-than-a-nondeterministic-tur.html},
  annote = {A very interesting view of several complexity classes from the perspective of counting complexity.

V{\'e}ase tambi{\'e}n Papadimitriou p{\'a}gina 521}
}

@article{KarpLiptontheorem2017,
  title = {Karp\textendash{{Lipton}} Theorem},
  copyright = {Creative Commons Attribution-ShareAlike License},
  abstract = {In complexity theory, the Karp\textendash{}Lipton theorem states that if the Boolean satisfiability problem (SAT) can be solved by Boolean circuits with a polynomial number of logic gates, then





          {$\Pi$}

            2


        =

          {$\Sigma$}

            2





    \{\textbackslash{}displaystyle \textbackslash{}Pi \_\{2\}=\textbackslash{}Sigma \_\{2\}\textbackslash,\}
   and therefore




          P
          H

        =

          {$\Sigma$}

            2


        .



    \{\textbackslash{}displaystyle \textbackslash{}mathrm \{PH\} =\textbackslash{}Sigma \_\{2\}.\textbackslash,\}

That is, if we assume that NP, the class of nondeterministic polynomial time problems, can be contained in the non-uniform polynomial time complexity class P/poly, then this assumption implies the collapse of the polynomial hierarchy at its second level. Such a collapse is believed unlikely, so the theorem is generally viewed by complexity theorists as evidence for the nonexistence of polynomial size circuits for SAT or for other NP-complete problems. A proof that such circuits do not exist would imply that P {$\not =$} NP. As P/poly contains all problems solvable in randomized polynomial time (Adleman's theorem), the Karp\textendash{}Lipton theorem is also evidence that the use of randomization does not lead to polynomial time algorithms for NP-complete problems.
The Karp\textendash{}Lipton theorem is named after Richard M. Karp and Richard J. Lipton, who first proved it in 1980. (Their original proof collapsed PH to




          {$\Sigma$}

            3




    \{\textbackslash{}displaystyle \textbackslash{}Sigma \_\{3\}\}
  , but Michael Sipser improved it to




          {$\Sigma$}

            2




    \{\textbackslash{}displaystyle \textbackslash{}Sigma \_\{2\}\}
  .)
Variants of the theorem state that, under the same assumption, MA = AM, and PH collapses to SP2 complexity class. There are stronger conclusions possible if PSPACE, or some other complexity classes are assumed to have polynomial-sized circuits; see P/poly. If NP is assumed to be a subset of BPP (which is a subset of P/poly), then the polynomial hierarchy collapses to BPP. If coNP is assumed to be subset of NP/poly, then the polynomial hierarchy collapses to its third level.},
  language = {en},
  urldate = {2018-07-28},
  journal = {Wikipedia},
  url = {https://en.wikipedia.org/w/index.php?title=Karp\%E2\%80\%93Lipton_theorem\&oldid=809572882},
  month = nov,
  year = {2017},
  file = {/home/pablo/Zotero/storage/T6SAS95S/index.html},
  note = {Page Version ID: 809572882}
}

@article{Barrettcomputationallandscapegeneral2017,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1702.08483},
  primaryClass = {quant-ph},
  title = {The Computational Landscape of General Physical Theories},
  abstract = {The emergence of quantum computers has challenged long-held beliefs about what is efficiently computable given our current physical theories. However, going back to the work of Abrams and Lloyd, changing one aspect of quantum theory can result in yet more dramatic increases in computational power, as well as violations of fundamental physical principles. Here we focus on efficient computation within a framework of general physical theories that make good operational sense. In prior work, Lee and Barrett showed that in any theory satisfying the principle of tomographic locality (roughly, local measurements suffice for tomography of multipartite states) the complexity bound on efficient computation is AWPP. This bound holds independently of whether the principle of causality (roughly, no signalling from the future) is satisfied. In this work we show that this bound is tight: there exists a theory satisfying both the principles of tomographic locality and causality which can efficiently decide everything in AWPP, and in particular can simulate any efficient quantum computation. Thus the class AWPP has a natural physical interpretation: it is precisely the class of problems that can be solved efficiently in tomographically-local theories. This theory is built upon a model of computing involving Turing machines with quasi-probabilities, to wit, machines with transition weights that can be negative but sum to unity over all branches. In analogy with the study of non-local quantum correlations, this leads us to question what physical principles recover the power of quantum computing. Along this line, we give some computational complexity evidence that quantum computation does not achieve the bound of AWPP.},
  language = {en},
  urldate = {2018-07-29},
  journal = {arXiv:1702.08483 [quant-ph]},
  url = {http://arxiv.org/abs/1702.08483},
  author = {Barrett, Jonathan and {de Beaudrap}, Niel and Hoban, Matty J. and Lee, Ciar{\'a}n M.},
  month = feb,
  year = {2017},
  keywords = {Quantum Physics,Computer Science - Computational Complexity},
  file = {/home/pablo/Zotero/storage/A6BCHV3L/Barrett et al. - 2017 - The computational landscape of general physical th.pdf},
  annote = {Comment: 15 pages, 4 figures. Comments welcome

Define BGP (problemas resolubles en la teor{\'i}a G con error acotado) en general para cualquier teor{\'i}a.

Motiva el estudio de PP (y de AWPP) como cota superior de cualquier clase de complejidad con soluciones con error acotado.}
}

@incollection{Quantumalgorithmsmatrix,
  title = {Quantum Algorithms for Matrix Multiplication and Product Verification},
  file = {/home/pablo/Zotero/storage/GENE7WM3/KN.pdf}
}

@article{VidickQuantumProofs2016,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1610.01664},
  title = {Quantum {{Proofs}}},
  volume = {11},
  issn = {1551-305X, 1551-3068},
  abstract = {Quantum information and computation provide a fascinating twist on the notion of proofs in computational complexity theory. For instance, one may consider a quantum computational analogue of the complexity class \textbackslash{}class\{NP\}, known as QMA, in which a quantum state plays the role of a proof (also called a certificate or witness), and is checked by a polynomial-time quantum computation. For some problems, the fact that a quantum proof state could be a superposition over exponentially many classical states appears to offer computational advantages over classical proof strings. In the interactive proof system setting, one may consider a verifier and one or more provers that exchange and process quantum information rather than classical information during an interaction for a given input string, giving rise to quantum complexity classes such as QIP, QSZK, and QMIP* that represent natural quantum analogues of IP, SZK, and MIP. While quantum interactive proof systems inherit some properties from their classical counterparts, they also possess distinct and uniquely quantum features that lead to an interesting landscape of complexity classes based on variants of this model. In this survey we provide an overview of many of the known results concerning quantum proofs, computational models based on this concept, and properties of the complexity classes they define. In particular, we discuss non-interactive proofs and the complexity class QMA, single-prover quantum interactive proof systems and the complexity class QIP, statistical zero-knowledge quantum interactive proof systems and the complexity class \textbackslash{}class\{QSZK\}, and multiprover interactive proof systems and the complexity classes QMIP, QMIP*, and MIP*.},
  language = {en},
  number = {1-2},
  urldate = {2018-08-02},
  journal = {Foundations and Trends\textregistered{} in Theoretical Computer Science},
  doi = {10.1561/0400000068},
  url = {http://arxiv.org/abs/1610.01664},
  author = {Vidick, Thomas and Watrous, John},
  year = {2016},
  keywords = {Quantum Physics,todo},
  pages = {1-215},
  file = {/home/pablo/Zotero/storage/XCQMMEBE/Vidick y Watrous - 2016 - Quantum Proofs.pdf},
  annote = {Comment: Survey published by NOW publishers

Leer sobre demostraci{\'o}n de QMA en PP en el otro paper de Watrous}
}

@misc{AaronsonmathsfBQPvsmathsfQMA2010,
  title = {$\mathsf{BQP}$ vs. $\mathsf{QMA}$},
  urldate = {2018-08-04},
  journal = {Theoretical Computer Science Stack Exchange},
  url = {https://cstheory.stackexchange.com/questions/3304/bqp-vs-qma},
  author = {Aaronson, Scott},
  year = {2010},
  file = {/home/pablo/Zotero/storage/8ZZHUURT/bqp-vs-qma.html}
}

@article{FortnowComplexityLimitationsQuantum,
  title = {Complexity {{Limitations}} on {{Quantum Computation}}},
  abstract = {We use the powerful tools of counting complexity and generic oracles to help understand the limitations of the complexity of quantum computation. We show several results for the probabilistic quantum class BQP.},
  language = {en},
  author = {Fortnow, Lance and Rogers, John},
  pages = {13},
  file = {/home/pablo/Zotero/storage/K8FT6EF9/Fortnow y Rogers - Complexity Limitations on Quantum Computation.pdf}
}

@misc{JordanQuantumAlgorithmZoo2011,
  title = {Quantum {{Algorithm Zoo}}},
  urldate = {2018-08-07},
  url = {https://math.nist.gov/quantum/zoo/\#BQP},
  author = {Jordan, Stephen},
  year = {2011},
  file = {/home/pablo/Zotero/storage/GFHBYY8M/zoo.html}
}

@misc{cccomplexitytheorya,
  title = {Cc.Complexity Theory - {{New}} Algorithm for {{Discrete}} Log and Its Implications for {{Quantum}} Computing},
  urldate = {2018-08-09},
  journal = {Theoretical Computer Science Stack Exchange},
  url = {https://cstheory.stackexchange.com/questions/18134/new-algorithm-for-discrete-log-and-its-implications-for-quantum-computing/18138},
  file = {/home/pablo/Zotero/storage/8P7GS9QA/18138.html}
}

@misc{ShtetlOptimizedBlogArchive,
  title = {Shtetl-{{Optimized}} \guillemotright{} {{Blog Archive}} \guillemotright{} {{Research}} Projects in Quantum Complexity Theory},
  language = {en-US},
  urldate = {2018-08-09},
  url = {https://www.scottaaronson.com/blog/?p=471},
  file = {/home/pablo/Zotero/storage/7DZLAUQ5/blog.html}
}

@incollection{AllenderOraclesprooftechniques1990,
  address = {{Berlin, Heidelberg}},
  title = {Oracles versus Proof Techniques That Do Not Relativize},
  volume = {450},
  isbn = {978-3-540-52921-7 978-3-540-47177-6},
  abstract = {Oracle constructions have long been used to provide evidence that certain questions in complexity theory cannot be resolved using the usual techniques of simulation and diagonalization. However, the existence of nonrelativizing proof techniques seems to call this practice into question. This paper reviews the status of nonrelativizing proof techniques, and argues that many oracle constructions still yield valuable information about problems in complexity theory.},
  language = {en},
  urldate = {2018-08-10},
  booktitle = {Algorithms},
  publisher = {{Springer Berlin Heidelberg}},
  url = {http://link.springer.com/10.1007/3-540-52921-7_54},
  author = {Allender, Eric},
  editor = {Goos, G. and Hartmanis, J. and Barstow, D. and Brauer, W. and Brinch Hansen, P. and Gries, D. and Luckham, D. and Moler, C. and Pnueli, A. and Seegm{\"u}ller, G. and Stoer, J. and Wirth, N. and Asano, Tetsuo and Ibaraki, Toshihide and Imai, Hiroshi and Nishizeki, Takao},
  year = {1990},
  pages = {39-52},
  file = {/home/pablo/Zotero/storage/G578ATTC/Allender - 1990 - Oracles versus proof techniques that do not relati.pdf},
  doi = {10.1007/3-540-52921-7_54}
}

@article{GreenIntroductionQuantumProgramming2013,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1304.5485},
  primaryClass = {quant-ph},
  title = {An {{Introduction}} to {{Quantum Programming}} in {{Quipper}}},
  volume = {7948},
  abstract = {Quipper is a recently developed programming language for expressing quantum computations. This paper gives a brief tutorial introduction to the language, through a demonstration of how to make use of some of its key features. We illustrate many of Quipper's language features by developing a few well known examples of Quantum computation, including quantum teleportation, the quantum Fourier transform, and a quantum circuit for addition.},
  language = {en},
  urldate = {2018-09-17},
  journal = {arXiv:1304.5485 [quant-ph]},
  doi = {10.1007/978-3-642-38986-3_10},
  url = {http://arxiv.org/abs/1304.5485},
  author = {Green, Alexander S. and Lumsdaine, Peter LeFanu and Ross, Neil J. and Selinger, Peter and Valiron, Beno{\^i}t},
  year = {2013},
  keywords = {Quantum Physics,Computer Science - Emerging Technologies,Computer Science - Programming Languages,Read,Quantum Programming Languages},
  pages = {110-124},
  file = {/home/pablo/Zotero/storage/N7IPL62F/Green et al. - 2013 - An Introduction to Quantum Programming in Quipper.pdf},
  annote = {Comment: 15 pages, RC2013}
}

@book{YingFoundationsquantumprogramming2016,
  address = {{Amsterdam}},
  title = {Foundations of Quantum Programming},
  isbn = {978-0-12-802306-8},
  lccn = {QA76.889 .Y56 2016},
  language = {en},
  publisher = {{Morgan Kaufmann is an imprint of Elsevier}},
  author = {Ying, Mingsheng},
  year = {2016},
  keywords = {Quantum computers,Programming languages (Electronic computers)},
  file = {/home/pablo/Zotero/storage/BBVF5Z8P/Ying - 2016 - Foundations of quantum programming.pdf},
  note = {OCLC: ocn938383107}
}

@article{AaronsonLimitsEfficientComputation,
  title = {Limits on {{Efficient Computation}} in the {{Physical World}}},
  language = {en},
  author = {Aaronson, Scott Joel},
  pages = {258},
  file = {/home/pablo/Zotero/storage/58XTFQLY/Aaronson - Limits on EÔ¨Écient Computation in the Physical Worl.pdf}
}

@misc{845ClassHome,
  title = {6.845 {{Class Home}}},
  urldate = {2018-09-30},
  url = {https://stellar.mit.edu/S/course/6/fa14/6.845/},
  keywords = {course}
}

@misc{04518400,
  title = {6.045/18.400 {{Class Home}}},
  urldate = {2018-09-30},
  url = {https://stellar.mit.edu/S/course/6/sp16/6.045/},
  keywords = {course},
  file = {/home/pablo/Zotero/storage/XDXLUNM7/6.html}
}

@misc{Physics219Course,
  title = {Physics 219 {{Course Information}}},
  urldate = {2018-09-30},
  url = {http://theory.caltech.edu/people/preskill/ph229/},
  keywords = {course},
  file = {/home/pablo/Zotero/storage/FQ9B3E9U/ph229.html}
}

@misc{CS395TTopicsQuantum,
  title = {{{CS395T Topics}} in {{Quantum}} and {{Classical Complexity Theory}}},
  urldate = {2018-09-30},
  url = {https://www.scottaaronson.com/qct2016/},
  keywords = {course,problems},
  file = {/home/pablo/Zotero/storage/23WZ6SU4/qct2016.html}
}

@misc{AdvancedComplexityTheory,
  title = {Advanced {{Complexity Theory}}},
  urldate = {2018-10-29},
  url = {https://people.csail.mit.edu/madhu/ST03/},
  file = {/home/pablo/Zotero/storage/UYVIQ4NX/ST03.html}
}

@book{RaoFastFouriertransform2010,
  address = {{Dordrecht ; New York}},
  series = {Signals and Communication Technology},
  title = {Fast {{Fourier}} Transform: Algorithms and Applications},
  isbn = {978-1-4020-6628-3 978-1-4020-6629-0},
  lccn = {TK5102.9 .R364 2010},
  shorttitle = {Fast {{Fourier}} Transform},
  language = {en},
  publisher = {{Springer}},
  author = {Rao, K. Ramamohan and Kim, D. N. and Hwang, J. J.},
  year = {2010},
  keywords = {Digital techniques Mathematics,Fourier transformations,Signal processing},
  file = {/home/pablo/Zotero/storage/WCX46JBY/Rao et al. - 2010 - Fast Fourier transform algorithms and application.pdf},
  note = {OCLC: ocn178312217}
}

@article{TangQuantuminspiredclassicalalgorithms2018,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1811.00414},
  primaryClass = {quant-ph},
  title = {Quantum-Inspired Classical Algorithms for Principal Component Analysis and Supervised Clustering},
  abstract = {We describe classical analogues to quantum algorithms for principal component analysis and nearest-centroid clustering. Given sampling assumptions, our classical algorithms run in time polylogarithmic in input, matching the runtime of the quantum algorithms with only polynomial slowdown. These algorithms are evidence that their corresponding problems do not yield exponential quantum speedups. To build our classical algorithms, we use the same techniques as applied in our previous work dequantizing a quantum recommendation systems algorithm. Thus, we provide further evidence for the strength of classical \$\textbackslash{}ell\^2\$-norm sampling assumptions when replacing quantum state preparation assumptions, in the machine learning domain.},
  urldate = {2018-11-07},
  journal = {arXiv:1811.00414 [quant-ph]},
  url = {http://arxiv.org/abs/1811.00414},
  author = {Tang, Ewin},
  month = oct,
  year = {2018},
  keywords = {Quantum Physics,Computer Science - Data Structures and Algorithms,Computer Science - Information Retrieval,Computer Science - Machine Learning},
  file = {/home/pablo/Zotero/storage/ZXIAIUV8/Tang - 2018 - Quantum-inspired classical algorithms for principa.pdf;/home/pablo/Zotero/storage/HLQE3EP4/1811.html},
  annote = {[object Object]

Comment: 5 pages}
}

@article{BravyiQuantumadvantageshallow2018,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1704.00690},
  title = {Quantum Advantage with Shallow Circuits},
  volume = {362},
  issn = {0036-8075, 1095-9203},
  abstract = {We prove that constant-depth quantum circuits are more powerful than their classical counterparts. To this end we introduce a non-oracular version of the BernsteinVazirani problem which we call the 2D Hidden Linear Function problem. An instance of the problem is specified by a quadratic form q that maps n-bit strings to integers modulo four. The goal is to identify a linear boolean function which describes the action of q on a certain subset of n-bit strings. We prove that any classical probabilistic circuit composed of bounded fan-in gates that solves the 2D Hidden Linear Function problem with high probability must have depth logarithmic in n. In contrast, we show that this problem can be solved with certainty by a constant-depth quantum circuit composed of one- and two-qubit gates acting locally on a two-dimensional grid.},
  language = {en},
  number = {6412},
  urldate = {2018-11-12},
  journal = {Science},
  doi = {10.1126/science.aar3106},
  url = {http://arxiv.org/abs/1704.00690},
  author = {Bravyi, Sergey and Gosset, David and Koenig, Robert},
  month = oct,
  year = {2018},
  keywords = {Quantum Physics,Computer Science - Computational Complexity},
  pages = {308-311},
  file = {/home/pablo/Zotero/storage/7VM8SFFX/Bravyi et al. - 2018 - Quantum advantage with shallow circuits.pdf}
}

@book{Moorenaturecomputation2011,
  address = {{Oxford [England] ; New York}},
  title = {The Nature of Computation},
  isbn = {978-0-19-923321-2},
  lccn = {QA267.7 .M66 2011},
  language = {en},
  publisher = {{Oxford University Press}},
  author = {Moore, Cristopher and Mertens, Stephan},
  year = {2011},
  keywords = {Computational complexity},
  file = {/home/pablo/Zotero/storage/ZFKW72N6/Cristopher Moore, Stephan Mertens-The Nature of Computation-Oxford University Press (2011).djvu},
  note = {OCLC: ocn180753706}
}

@book{vanLeeuwenHandbookTheoreticalComputer1990,
  title = {Handbook of {{Theoretical Computer Science}}},
  volume = {A},
  isbn = {0 262 22038 5},
  shorttitle = {Handbook of {{Theoretical Computer Science}}},
  language = {en},
  publisher = {{The MIT Press}},
  author = {{van Leeuwen}},
  year = {1990},
  file = {/home/pablo/Zotero/storage/JF77M5GI/HandbookOfTheoretical.pdf},
  annote = {El primer cap{\'i}tulo de Ende Vam Boas tiene una discusi{\'o}n sobre equivalencias en complejidad entre modelos de computaci{\'o}n cl{\'a}sicos.

~}
}

@book{AroraComputationalComplexityModern2009,
  title = {Computational {{Complexity A Modern Approach}}},
  isbn = {978-0-521-42426-4},
  shorttitle = {Computational {{Complexity}}},
  language = {en},
  publisher = {{Cambridge University Press}},
  author = {Arora, Sanjeev and Barak, Boaz},
  year = {2009},
  file = {/home/pablo/Zotero/storage/AFKIY6BL/Arora y Barak - Computational Complexity.pdf},
  annote = {Tiene cap{\'i}tulos sobre:

- Pruebas de teoremas de jerarqu{\'i}a en todos los casos conocidos

- Robustness de BPP

- MA, QMA, IP, dIP, QIP}
}

@article{FernandezQuaternionicComputing2003,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {quant-ph/0307017},
  title = {Quaternionic {{Computing}}},
  abstract = {We introduce a model of computation based on quaternions, which is inspired on the quantum computing model. Pure states are vectors of a suitable linear space over the quaternions. Other aspects of the theory are the same as in quantum computing: superposition and linearity of the state space, unitarity of the transformations, and projective measurements. However, one notable exception is the fact that quaternionic circuits do not have a uniquely defined behaviour, unless a total ordering of evaluation of the gates is defined. Given such an ordering a unique unitary operator can be associated with the quaternionic circuit and a proper semantics of computation can be associated with it.},
  language = {en},
  urldate = {2018-12-18},
  journal = {arXiv:quant-ph/0307017},
  url = {http://arxiv.org/abs/quant-ph/0307017},
  author = {Fernandez, Jose M. and Schneeberger, William A.},
  month = jul,
  year = {2003},
  keywords = {Quantum Physics,Computer Science - Computational Complexity},
  file = {/home/pablo/Zotero/storage/HF7ECXXX/Fernandez y Schneeberger - 2003 - Quaternionic Computing.pdf},
  annote = {Comment: Version 2: 32 pages, 8 PS figures. Ver 2 is a substantially revised version, which addresses a major problem with the previous version: the output of quaternionic circuits is in general ambiguous unless an total order of evaluation of gates is defined. The main complexity result is essentially unaffected. This version addresses this issue and discusses in detail the complexity and physical consequences of this "ambiguity"

Interesting when it comes to the discussion of how to transform a quantum circuit diagram to a serialized version and also because of its remarks on the crucial property of tensor product and composition}
}

@incollection{CobhamIntrinsicComputationalDifficulty1965,
  title = {The {{Intrinsic Computational Difficulty}} of {{Functions}}},
  booktitle = {Logic, {{Methodology}} and {{Philosophy}} of {{Science}}: {{Proceedings}} of the 1964 {{International Congress}} ({{Studies}} in {{Logic}} and the {{Foundations}} of {{Mathematics}})},
  publisher = {{North-Holland Publishing}},
  author = {Cobham, Alan},
  editor = {{Bar-Hillel}, Yehoshua},
  year = {1965},
  pages = {24--30}
}

@book{LewisElementstheorycomputation1998,
  address = {{Upper Saddle River, N.J}},
  edition = {2nd ed},
  title = {Elements of the Theory of Computation},
  isbn = {978-0-13-262478-7},
  lccn = {QA267 .L49 1998},
  language = {en},
  publisher = {{Prentice-Hall}},
  author = {Lewis, Harry R. and Papadimitriou, Christos H.},
  year = {1998},
  keywords = {Computational complexity,Logic; Symbolic and mathematical,Formal languages,Machine theory},
  file = {/home/pablo/Zotero/storage/BXLK7DWT/Lewis y Papadimitriou - 1998 - Elements of the theory of computation.pdf}
}

@article{GreenQuipperScalableQuantum2013,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1304.3390},
  title = {Quipper: {{A Scalable Quantum Programming Language}}},
  volume = {48},
  issn = {03621340},
  shorttitle = {Quipper},
  abstract = {The field of quantum algorithms is vibrant. Still, there is currently a lack of programming languages for describing quantum computation on a practical scale, i.e., not just at the level of toy problems. We address this issue by introducing Quipper, a scalable, expressive, functional, higher-order quantum programming language. Quipper has been used to program a diverse set of non-trivial quantum algorithms, and can generate quantum gate representations using trillions of gates. It is geared towards a model of computation that uses a classical computer to control a quantum device, but is not dependent on any particular model of quantum hardware. Quipper has proven effective and easy to use, and opens the door towards using formal methods to analyze quantum algorithms.},
  language = {en},
  number = {6},
  urldate = {2019-02-09},
  journal = {ACM SIGPLAN Notices},
  doi = {10.1145/2499370.2462177},
  url = {http://arxiv.org/abs/1304.3390},
  author = {Green, Alexander S. and Lumsdaine, Peter LeFanu and Ross, Neil J. and Selinger, Peter and Valiron, Beno{\^i}t},
  month = jun,
  year = {2013},
  keywords = {Quantum Physics,Computer Science - Emerging Technologies,Computer Science - Programming Languages,D.3.1,Read,Quantum Programming Languages},
  pages = {333},
  file = {/home/pablo/Zotero/storage/WN23UT8Q/Green et al. - 2013 - Quipper A Scalable Quantum Programming Language.pdf},
  annote = {Comment: 10 pages, PLDI 2013}
}

@article{RossAlgebraicLogicalMethods2015,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1510.02198},
  primaryClass = {quant-ph},
  title = {Algebraic and {{Logical Methods}} in {{Quantum Computation}}},
  abstract = {This thesis contains contributions to the theory of quantum computation. We first define a new method to efficiently approximate special unitary operators. Specifically, given a special unitary U and a precision \{\textbackslash{}epsilon\} {$>$} 0, we show how to efficiently find a sequence of Clifford+V or Clifford+T operators whose product approximates U up to \{\textbackslash{}epsilon\} in the operator norm. In the general case, the length of the approximating sequence is asymptotically optimal. If the unitary to approximate is diagonal then our method is optimal: it yields the shortest sequence approximating U up to \{\textbackslash{}epsilon\}. Next, we introduce a mathematical formalization of a fragment of the Quipper quantum programming language. We define a typed lambda calculus called Proto-Quipper which formalizes a restricted but expressive fragment of Quipper. The type system of Proto-Quipper is based on intuitionistic linear logic and prohibits the duplication of quantum data, in accordance with the no-cloning property of quantum computation. We prove that Proto-Quipper is type-safe in the sense that it enjoys the subject reduction and progress properties.},
  language = {en},
  urldate = {2019-02-23},
  journal = {arXiv:1510.02198 [quant-ph]},
  url = {http://arxiv.org/abs/1510.02198},
  author = {Ross, Neil J.},
  month = oct,
  year = {2015},
  keywords = {Quantum Physics},
  file = {/home/pablo/Zotero/storage/RWJVS6MH/Ross - 2015 - Algebraic and Logical Methods in Quantum Computati.pdf},
  annote = {Comment: Ph.D. thesis, Dalhousie University, August 2015}
}

@article{RiosCategoricalModelQuantum2018,
  title = {A {{Categorical Model}} for a {{Quantum Circuit Description Language}} ({{Extended Abstract}})},
  volume = {266},
  issn = {2075-2180},
  language = {en},
  urldate = {2019-02-23},
  journal = {Electronic Proceedings in Theoretical Computer Science},
  doi = {10.4204/EPTCS.266.11},
  url = {http://arxiv.org/abs/1706.02630v2},
  author = {Rios, Francisco and Selinger, Peter},
  month = feb,
  year = {2018},
  pages = {164-178},
  file = {/home/pablo/Zotero/storage/FLMW8R2G/Rios y Selinger - 2018 - A Categorical Model for a Quantum Circuit Descript.pdf}
}

@article{BuhrmanComplexitymeasuresdecision2002,
  title = {Complexity Measures and Decision Tree Complexity: A Survey},
  volume = {288},
  issn = {03043975},
  shorttitle = {Complexity Measures and Decision Tree Complexity},
  abstract = {We discuss several complexity measures for Boolean functions: certi{\"y}cate complexity, sensitivity, block sensitivity, and the degree of a representing or approximating polynomial. We survey the relations and biggest gaps known between these measures, and show how they give bounds for the decision tree complexity of Boolean functions on deterministic, randomized, and quantum computers. c 2002 Elsevier Science B.V. All rights reserved.},
  language = {en},
  number = {1},
  urldate = {2019-03-04},
  journal = {Theoretical Computer Science},
  doi = {10.1016/S0304-3975(01)00144-X},
  url = {http://linkinghub.elsevier.com/retrieve/pii/S030439750100144X},
  author = {Buhrman, Harry and {de Wolf}, Ronald},
  month = oct,
  year = {2002},
  pages = {21-43},
  file = {/home/pablo/Zotero/storage/LFJRG7IM/Buhrman y de Wolf - 2002 - Complexity measures and decision tree complexity .pdf}
}

@misc{AaronsonLecturenotes28th2016,
  title = {Lecture Notes for the 28th {{McGill Invitational Workshop}} on {{Computational Complexity}}},
  author = {Aaronson, Scott},
  year = {2016},
  file = {/home/pablo/Zotero/storage/ASDQRTAY/barbados-2016.pdf}
}

@article{dawson2005,
  title={The solovay-kitaev algorithm},
  author={Dawson, Christopher M and Nielsen, Michael A},
  journal={arXiv preprint quant-ph/0505030},
  year={2005}
}


@article{AharonovQuantumCircuitsMixed1998,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {quant-ph/9806029},
  title = {Quantum {{Circuits}} with {{Mixed States}}},
  abstract = {Current formal models for quantum computation deal only with unitary gates operating on ``pure quantum states''. In these models it is difficult or impossible to deal formally with several central issues: measurements in the middle of the computation; decoherence and noise, using probabilistic subroutines, and more. It turns out, that the restriction to unitary gates and pure states is unnecessary. In this paper we generalize the formal model of quantum circuits to a model in which the state can be a general quantum state, namely a mixed state, or a ``density matrix'', and the gates can be general quantum operations, not necessarily unitary. The new model is shown to be equivalent in computational power to the standard one, and the problems mentioned above essentially disappear.},
  language = {en},
  urldate = {2019-04-18},
  journal = {arXiv:quant-ph/9806029},
  url = {http://arxiv.org/abs/quant-ph/9806029},
  author = {Aharonov, Dorit and Kitaev, Alexei and Nisan, Noam},
  month = jun,
  year = {1998},
  keywords = {Quantum Physics},
  file = {/home/pablo/Zotero/storage/7R276V45/Aharonov et al. - 1998 - Quantum Circuits with Mixed States.pdf},
  annote = {Comment: 20 pages, Latex. In ``Proceedings of the Thirtieth Annual ACM Symposium on Theory of Computation (STOC)'', pages 20-30, 1997}
}

@book{LauFunctionAlgebrasFinite2006,
  address = {{Berlin Heidelberg}},
  series = {Springer {{Monographs}} in {{Mathematics}}},
  title = {Function {{Algebras}} on {{Finite Sets}}: {{Basic Course}} on {{Many}}-{{Valued Logic}} and {{Clone Theory}}},
  isbn = {978-3-540-36022-3},
  shorttitle = {Function {{Algebras}} on {{Finite Sets}}},
  abstract = {Functions which are defined on finite sets occur in almost all fields of mathematics. For more than 80 years algebras whose universes are such functions (so-called function algebras), have been intensively studied. This book gives a broad introduction to the theory of function algebras and leads to the cutting edge of research. To familiarize the reader from the very beginning on with the algebraic side of function algebras the more general concepts of the Universal Algebra is given in the first part of the book. The second part on fuction algebras covers the following topics: Galois-connection between function algebras and relation algebras, completeness criterions, clone theory. This book is an insdispensible source on function algebras for graduate students and researchers in mathematical logic and theoretical computer science.},
  language = {en},
  urldate = {2019-04-19},
  publisher = {{Springer-Verlag}},
  url = {https://www.springer.com/la/book/9783540360223},
  author = {Lau, Dietlinde},
  year = {2006},
  file = {/home/pablo/Zotero/storage/3LVULKK3/9783540360223.html}
}

@article{MolinaRevisitingsimulationquantum,
  title = {Revisiting the Simulation of Quantum {{Turing}} Machines by Quantum Circuits},
  abstract = {Yao (1993) proved that quantum Turing machines and uniformly generated quantum circuits are polynomially equivalent computational models: t {$\geq$} n steps of a quantum Turing machine running on an input of length n can be simulated by a uniformly generated family of quantum circuits with size quadratic in t, and a polynomial-time uniformly generated family of quantum circuits can be simulated by a quantum Turing machine running in polynomial time. We revisit the simulation of quantum Turing machines with uniformly generated quantum circuits, which is the more challenging of the two simulation tasks, and present a variation on the simulation method employed by Yao together with an analysis of it. This analysis reveals that the simulation of quantum Turing machines can be performed by quantum circuits having depth linear in t, rather than quadratic depth, and can be extended to variants of quantum Turing machines, such as ones having multi-dimensional tapes. Our analysis is based on an extension of a method of Arrighi, Nesme, and Werner (2011) that allows for the localization of causal unitary evolutions.},
  language = {en},
  author = {Molina, Abel and Watrous, John},
  keywords = {todo},
  pages = {27},
  file = {/home/pablo/Zotero/storage/3QQ3WSMT/Molina y Watrous - Revisiting the simulation of quantum Turing machin.pdf}
}

@article{Watrousintroductionquantuminformation,
  title = {An Introduction to Quantum Information and Quantum Circuits},
  language = {en},
  author = {Watrous, John},
  keywords = {todo},
  pages = {16},
  file = {/home/pablo/Zotero/storage/8BCNLVPL/Watrous - An introduction to quantum information and quantum.pdf}
}

@article{SaxenaProgressPolynomialIdentity2014,
  title = {Progress on {{Polynomial Identity Testing}}},
  language = {en},
  number = {99},
  author = {Saxena, Nitin},
  year = {2014},
  pages = {31},
  file = {/home/pablo/Zotero/storage/JPBNQTIE/Saxena - Progress on Polynomial Identity Testing.pdf}
}

@misc{KatzNotesComplexityTheory,
  title = {Notes on {{Complexity Theory}}},
  year = {2005},
  urldate = {2019-05-03},
  url = {http://www.cs.umd.edu/~jkatz/complexity/f05/lecture7.pdf},
  author = {Katz, Jonathan},
  file = {/home/pablo/Zotero/storage/V5WWIDIS/lecture7.pdf}
}

@article{Selingersurveygraphicallanguages2010,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {0908.3347},
  primaryClass = {math},
  title = {A Survey of Graphical Languages for Monoidal Categories},
  volume = {813},
  abstract = {This article is intended as a reference guide to various notions of monoidal categories and their associated string diagrams. It is hoped that this will be useful not just to mathematicians, but also to physicists, computer scientists, and others who use diagrammatic reasoning. We have opted for a somewhat informal treatment of topological notions, and have omitted most proofs. Nevertheless, the exposition is sufficiently detailed to make it clear what is presently known, and to serve as a starting place for more in-depth study. Where possible, we provide pointers to more rigorous treatments in the literature. Where we include results that have only been proved in special cases, we indicate this in the form of caveats.},
  language = {en},
  urldate = {2019-05-06},
  journal = {arXiv:0908.3347 [math]},
  doi = {10.1007/978-3-642-12821-9_4},
  url = {http://arxiv.org/abs/0908.3347},
  author = {Selinger, Peter},
  year = {2010},
  keywords = {18D10,Mathematics - Category Theory},
  pages = {289-355},
  file = {/home/pablo/Zotero/storage/UXBL943U/Selinger - 2010 - A survey of graphical languages for monoidal categ.pdf}
}

@inproceedings{Lenstranumberfieldsieve1990a,
  title = {The Number Field Sieve},
  isbn = {0-89791-361-2},
  booktitle = {Proceedings of the Twenty-Second Annual {{ACM}} Symposium on {{Theory}} of Computing},
  publisher = {{ACM}},
  author = {Lenstra, Arjen K. and Lenstra Jr, Hendrik W. and Manasse, Mark S. and Pollard, John M.},
  year = {1990},
  pages = {564-572},
  file = {/home/pablo/Zotero/storage/UTNIIDW9/Lenstra-Lenstra-Manasse-Pollard-The number field sieve.pdf}
}

@article{CleveQuantumAlgorithmsRevisited1998,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {quant-ph/9708016},
  title = {Quantum {{Algorithms Revisited}}},
  volume = {454},
  issn = {1471-2946},
  abstract = {Quantum computers use the quantum interference of different computational paths to enhance correct outcomes and suppress erroneous outcomes of computations. A common pattern underpinning quantum algorithms can be identified when quantum computation is viewed as multi-particle interference. We use this approach to review (and improve) some of the existing quantum algorithms and to show how they are related to different instances of quantum phase estimation. We provide an explicit algorithm for generating any prescribed interference pattern with an arbitrary precision.},
  language = {en},
  number = {1969},
  urldate = {2019-05-23},
  journal = {Proceedings of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences},
  doi = {10.1098/rspa.1998.0164},
  url = {http://arxiv.org/abs/quant-ph/9708016},
  author = {Cleve, Richard and Ekert, Artur and Macchiavello, Chiara and Mosca, Michele},
  month = jan,
  year = {1998},
  keywords = {Quantum Physics},
  pages = {339-354},
  file = {/home/pablo/Zotero/storage/ZH4SSQEG/Cleve et al. - 1998 - Quantum Algorithms Revisited.pdf},
  annote = {Comment: 18 pages, LaTeX, 7 figures. Submitted to Proc. Roy. Soc. Lond. A}
}

@article{MiranskyyTestingQuantumPrograms2018,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1812.09261},
  primaryClass = {quant-ph},
  title = {On {{Testing Quantum Programs}}},
  abstract = {A quantum computer (QC) can solve many computational problems more efficiently than a classic one. The field of QCs is growing: companies (such as DWave, IBM, Google, and Microsoft) are building QC offerings. We position that software engineers should look into defining a set of software engineering practices that apply to QC's software. To start this process, we give examples of challenges associated with testing such software and sketch potential solutions to some of these challenges.},
  language = {en},
  urldate = {2019-06-01},
  journal = {arXiv:1812.09261 [quant-ph]},
  url = {http://arxiv.org/abs/1812.09261},
  author = {Miranskyy, Andriy and Zhang, Lei},
  month = dec,
  year = {2018},
  keywords = {Quantum Physics,Computer Science - Emerging Technologies,Computer Science - Software Engineering},
  file = {/home/pablo/Zotero/storage/DYPJHG69/Miranskyy y Zhang - 2018 - On Testing Quantum Programs.pdf},
  annote = {Comment: A condensed version to appear in Proceedings of the 41st International Conference on Software Engineering (ICSE 2019)}
}

@inproceedings{Arcuripracticalguideusing2011,
  address = {{Waikiki, Honolulu, HI, USA}},
  title = {A Practical Guide for Using Statistical Tests to Assess Randomized Algorithms in Software Engineering},
  isbn = {978-1-4503-0445-0},
  abstract = {Randomized algorithms have been used to successfully address many different types of software engineering problems. This type of algorithms employ a degree of randomness as part of their logic. Randomized algorithms are useful for difficult problems where a precise solution cannot be derived in a deterministic way within reasonable time. However, randomized algorithms produce different results on every run when applied to the same problem instance. It is hence important to assess the effectiveness of randomized algorithms by collecting data from a large enough number of runs. The use of rigorous statistical tests is then essential to provide support to the conclusions derived by analyzing such data. In this paper, we provide a systematic review of the use of randomized algorithms in selected software engineering venues in 2009. Its goal is not to perform a complete survey but to get a representative snapshot of current practice in software engineering research. We show that randomized algorithms are used in a significant percentage of papers but that, in most cases, randomness is not properly accounted for. This casts doubts on the validity of most empirical results assessing randomized algorihtms. There are numerous statistical tests, based on different assumptions, and it is not always clear when and how to use these tests. We hence provide practical guidelines to support empirical research on randomized algorithms in software engineering.},
  language = {en},
  urldate = {2019-06-02},
  booktitle = {Proceeding of the 33rd International Conference on {{Software}} Engineering - {{ICSE}} '11},
  publisher = {{ACM Press}},
  doi = {10.1145/1985793.1985795},
  url = {http://portal.acm.org/citation.cfm?doid=1985793.1985795},
  author = {Arcuri, Andrea and Briand, Lionel},
  year = {2011},
  pages = {1},
  file = {/home/pablo/Zotero/storage/JD5NETH5/Arcuri y Briand - 2011 - A practical guide for using statistical tests to a.pdf}
}

@article{AgrawalPRIMES2004,
  title = {{{PRIMES Is}} in {{P}}},
  volume = {160},
  issn = {0003-486X},
  abstract = {We present an unconditional deterministic polynomial-time algorithm that determines whether an input number is prime or composite.},
  number = {2},
  urldate = {2019-06-03},
  journal = {Annals of Mathematics},
  url = {https://www.jstor.org/stable/3597229},
  author = {Agrawal, Manindra and Kayal, Neeraj and Saxena, Nitin},
  year = {2004},
  pages = {781-793}
}

@misc{OptionsApplicative,
  title = {Options.{{Applicative}}},
  urldate = {2019-06-13},
  url = {https://hackage.haskell.org/package/optparse-applicative-0.14.3.0/docs/Options-Applicative.html},
  file = {/home/pablo/Zotero/storage/MS3KCPBR/Options-Applicative.html}
}

@techreport{KnillConventionsquantumpseudocode1996,
  title = {Conventions for Quantum Pseudocode},
  abstract = {The U.S. Department of Energy's Office of Scientific and Technical Information},
  language = {English},
  number = {LA-UR-96-2724},
  urldate = {2019-06-13},
  institution = {{Los Alamos National Lab., NM (United States)}},
  url = {https://www.osti.gov/biblio/366453},
  author = {Knill, E.},
  month = jun,
  year = {1996},
  file = {/home/pablo/Zotero/storage/XX6EFH2N/Knill - 1996 - Conventions for quantum pseudocode.pdf;/home/pablo/Zotero/storage/9SR4L38V/366453.html},
  doi = {10.2172/366453}
}

@article{MarlowHaskell2010language2010,
  title = {Haskell 2010 Language Report},
  urldate = {2019-06-13},
  url = {https://www.haskell.org/definition/haskell2010.pdf},
  author = {Marlow, Simon},
  year = {2010},
  pages = {329},
  file = {/home/pablo/Zotero/storage/7X3WQWLG/haskell2010.pdf}
}

@misc{GlasgowHaskellCompiler2019,
  title = {The {{Glasgow Haskell Compiler}}},
  urldate = {2019-06-13},
  url = {https://www.haskell.org/ghc/},
  year = {2019},
  file = {/home/pablo/Zotero/storage/6ANHMJA9/ghc.html}
}

@book{HuttonProgramminghaskell2016,
  title = {Programming in Haskell},
  publisher = {{Cambridge University Press}},
  author = {Hutton, Graham},
  year = {2016},
  file = {/home/pablo/Zotero/storage/UU9XCUXS/books.html}
}

@misc{SnoymanHaskellToolStack2019,
  title = {The {{Haskell Tool Stack}}},
  urldate = {2019-06-13},
  url = {https://docs.haskellstack.org/en/stable/README/},
  collaborator = {Snoyman, Michael and Borsboom, Emanuel},
  year = {2019},
  file = {/home/pablo/Zotero/storage/SAFV3ZPQ/README.html}
}

@article{Pomerancepseudoprimes25101980,
  title = {The Pseudoprimes to 25{$\cdot$} 10{$^{9}$}},
  volume = {35},
  number = {151},
  journal = {Mathematics of Computation},
  author = {Pomerance, Carl and Selfridge, John L. and Wagstaff, Samuel S.},
  year = {1980},
  pages = {1003--1026},
  file = {/home/pablo/Zotero/storage/UT5SU6V7/Pomerance et al. - 1980 - The pseudoprimes to 25‚ãÖ 10‚Åπ.pdf;/home/pablo/Zotero/storage/8MY92W5E/S0025-5718-1980-0572872-7.html}
}

@incollection{FortnowComplexityTheoryRetrospective1997,
  address = {{Berlin, Heidelberg}},
  title = {Complexity {{Theory Retrospective II}}},
  isbn = {978-0-387-94973-4},
  urldate = {2019-06-15},
  publisher = {{Springer-Verlag}},
  url = {http://dl.acm.org/citation.cfm?id=284842.284846},
  author = {Fortnow, Lance},
  editor = {Hemaspaandra, Lane A. and Selman, Alan L.},
  year = {1997},
  pages = {81--107}
}

@article{FeynmanSimulatingphysicscomputers1982,
  title = {Simulating Physics with Computers},
  volume = {21},
  number = {6},
  journal = {International journal of theoretical physics},
  author = {Feynman, Richard P.},
  year = {1982},
  pages = {467--488},
  file = {/home/pablo/Zotero/storage/89V7IKBR/Feynman - 1982 - Simulating physics with computers.pdf;/home/pablo/Zotero/storage/LXV6IBQT/10.html}
}

@article{Wootterssinglequantumcannot1982,
  title = {A Single Quantum Cannot Be Cloned},
  volume = {299},
  copyright = {1982 Nature Publishing Group},
  issn = {1476-4687},
  abstract = {If a photon of definite polarization encounters an excited atom, there is typically some nonvanishing probability that the atom will emit a second photon by stimulated emission. Such a photon is guaranteed to have the same polarization as the original photon. But is it possible by this or any other process to amplify a quantum state, that is, to produce several copies of a quantum system (the polarized photon in the present case) each having the same state as the original? If it were, the amplifying process could be used to ascertain the exact state of a quantum system: in the case of a photon, one could determine its polarization by first producing a beam of identically polarized copies and then measuring the Stokes parameters1. We show here that the linearity of quantum mechanics forbids such replication and that this conclusion holds for all quantum systems.},
  language = {En},
  number = {5886},
  urldate = {2019-06-16},
  journal = {Nature},
  doi = {10.1038/299802a0},
  url = {https://www.nature.com/articles/299802a0},
  author = {Wootters, W. K. and Zurek, W. H.},
  month = oct,
  year = {1982},
  pages = {802},
  file = {/home/pablo/Zotero/storage/R8V8RF7I/299802a0.html}
}

@article{Groverfastquantummechanical1996,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {quant-ph/9605043},
  title = {A Fast Quantum Mechanical Algorithm for Database Search},
  abstract = {Imagine a phone directory containing N names arranged in completely random order. In order to find someone's phone number with a 50\% probability, any classical algorithm (whether deterministic or probabilistic) will need to look at a minimum of N/2 names. Quantum mechanical systems can be in a superposition of states and simultaneously examine multiple names. By properly adjusting the phases of various operations, successful computations reinforce each other while others interfere randomly. As a result, the desired phone number can be obtained in only O(sqrt(N)) steps. The algorithm is within a small constant factor of the fastest possible quantum mechanical algorithm.},
  urldate = {2019-06-16},
  journal = {arXiv:quant-ph/9605043},
  url = {http://arxiv.org/abs/quant-ph/9605043},
  author = {Grover, Lov K.},
  month = may,
  year = {1996},
  keywords = {Quantum Physics},
  file = {/home/pablo/Zotero/storage/QIIILZ9A/Grover - 1996 - A fast quantum mechanical algorithm for database s.pdf;/home/pablo/Zotero/storage/NV2UQFWM/9605043.html},
  annote = {Comment: 8 pages, single postscript file. This is an updated version of a paper that was originally presented at STOC 1996. The algorithm is the same; however, the proof has been simplified by using a new interpretation termed "inversion about average." Also a few recently discovered insights have been added. Journal Ref.: Proceedings, 28th Annual ACM Symposium on the Theory of Computing (STOC), May 1996, pages 212-219}
}

@inproceedings{ShorAlgorithmsquantumcomputation1994,
  title = {Algorithms for Quantum Computation: Discrete Logarithms and Factoring},
  shorttitle = {Algorithms for Quantum Computation},
  abstract = {A computer is generally considered to be a universal computational device; i.e., it is believed able to simulate any physical computational device with a cost in computation time of at most a polynomial factor: It is not clear whether this is still true when quantum mechanics is taken into consideration. Several researchers, starting with David Deutsch, have developed models for quantum mechanical computers and have investigated their computational properties. This paper gives Las Vegas algorithms for finding discrete logarithms and factoring integers on a quantum computer that take a number of steps which is polynomial in the input size, e.g., the number of digits of the integer to be factored. These two problems are generally considered hard on a classical computer and have been used as the basis of several proposed cryptosystems. We thus give the first examples of quantum cryptanalysis.{$<>$}},
  booktitle = {Proceedings 35th {{Annual Symposium}} on {{Foundations}} of {{Computer Science}}},
  doi = {10.1109/SFCS.1994.365700},
  author = {Shor, P. W.},
  month = nov,
  year = {1994},
  keywords = {Circuit simulation,computational complexity,Computational modeling,Computer simulation,Costs,Cryptography,cryptosystems,discrete logarithms,factoring,Las Vegas algorithms,Mechanical factors,parallel algorithms,physical computational device,Physics computing,polynomial factor,Polynomials,quantum computation algorithms,quantum computer,Quantum computing,Quantum mechanics},
  pages = {124-134},
  file = {/home/pablo/Zotero/storage/KBW4X6ND/365700.html}
}

@techreport{RazOracleSeparationBQP2018,
  title = {Oracle {{Separation}} of {{BQP}} and {{PH}}},
  number = {107},
  urldate = {2019-06-16},
  url = {https://eccc.weizmann.ac.il/report/2018/107/},
  author = {Raz, Ran and Tal, Avishay},
  year = {2018},
  keywords = {BQP,oracle separation,polynomial hierarchy},
  file = {/home/pablo/Zotero/storage/8DJ2DTJW/Raz y Tal - 2018 - Oracle Separation of BQP and PH.pdf;/home/pablo/Zotero/storage/H25MXL6G/107.html}
}

@article{BernardyLinearHaskellPractical2017,
  title = {Linear {{Haskell}}: {{Practical Linearity}} in a {{Higher}}-Order {{Polymorphic Language}}},
  volume = {2},
  issn = {2475-1421},
  shorttitle = {Linear {{Haskell}}},
  abstract = {Linear type systems have a long and storied history, but not a clear path forward to integrate with existing languages such as OCaml or Haskell. In this paper, we study a linear type system designed with two crucial properties in mind: backwards-compatibility and code reuse across linear and non-linear users of a library. Only then can the benefits of linear types permeate conventional functional programming. Rather than bifurcate types into linear and non-linear counterparts, we instead attach linearity to function arrows. Linear functions can receive inputs from linearly-bound values, but can also operate over unrestricted, regular values.  To demonstrate the efficacy of our linear type system~\textemdash{}~both how easy it can be integrated in an existing language implementation and how streamlined it makes it to write programs with linear types~\textemdash{}~we implemented our type system in ghc, the leading Haskell compiler, and demonstrate two kinds of applications of linear types: mutable data with pure interfaces; and enforcing protocols in I/O-performing functions.},
  number = {POPL},
  urldate = {2019-06-16},
  journal = {Proc. ACM Program. Lang.},
  doi = {10.1145/3158093},
  url = {http://doi.acm.org/10.1145/3158093},
  author = {Bernardy, Jean-Philippe and Boespflug, Mathieu and Newton, Ryan R. and Peyton Jones, Simon and Spiwack, Arnaud},
  month = dec,
  year = {2017},
  keywords = {GHC,Haskell,laziness,linear logic,linear types,polymorphism,typestate},
  pages = {5:1--5:29},
  file = {/home/pablo/Zotero/storage/GS7Z7XAL/Bernardy et al. - 2017 - Linear Haskell Practical Linearity in a Higher-or.pdf}
}
